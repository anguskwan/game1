var EventEmitter = require('events').EventEmitter;
var util = require('util');
var utils = require('../../util/utils');
var ws = require('ws').Server;
var zlib = require('zlib');
var logger = require('pomelo-logger').getLogger('pomelo-rpc', __filename);
var Tracer = require('../../util/tracer');

var DEFAULT_ZIP_LENGTH = 256;
var DEFAULT_USE_ZIP_COMPRESS = true;

var Acceptor = function (opts, cb) {
    EventEmitter.call(this);
    this.bufferMsg = opts.bufferMsg;
    this.debugBufferMsgInterval = opts.debugBufferMsgInterval;
    this.interval = opts.interval;  // flush interval in ms
    this.rpcDebugLog = opts.rpcDebugLog;
    this.rpcLogger = opts.rpcLogger;
    this.whitelist = opts.whitelist;
    this._interval = null;          // interval object
    this.sockets = {};
    this.msgQueues = {};
    this.cb = cb;
    this.doZipLength = opts.doZipLength || DEFAULT_ZIP_LENGTH;
    this.useZipCompress = opts.useZipCompress || DEFAULT_USE_ZIP_COMPRESS;
};
util.inherits(Acceptor, EventEmitter);

var pro = Acceptor.prototype;

pro.listen = function (port) {
    //check status
    if (!!this.inited) {
        utils.invokeCallback(this.cb, new Error('already inited.'));
        return;
    }
    this.inited = true;

    var self = this;

    this.server = new ws({port: port});

    this.server.on('error', function (err) {
        logger.error('rpc server port: %s is error: %s', port, err.stack);
        self.emit('error', err);
    });

    this.server.on('connection', function (socket) {
        socket.id = '' + socket._socket.remoteAddress + ':' + socket._socket.remotePort;
        self.sockets[socket.id] = socket;

        self.emit('connection', {id: socket.id, ip: socket._socket.remoteAddress});

        var processPkg = function (pkg) {
            logger.debug("ws rpc server received message, len: %s, message: %s", pkg.length, pkg);
            pkg = JSON.parse(pkg);

            if (pkg instanceof Array) {
                processMsgs(socket, self, pkg);
            } else {
                processMsg(socket, self, pkg);
            }
        }

        socket.on('message', function (data, flags) {
            try {
                if (flags.binary) {
                    logger.debug('ws rpc received message flags.binary, len: %s', data.length);
                    return zlib.gunzip(data, function (err, result) {
                        if (!!err) {
                            logger.error('ws rpc server received binary message error: %s', err.stack);
                            return;
                        }
                        logger.debug("ws rpc server received message unzip len: %s, message: %s", result.length,
                                     result);
                        processPkg(result);
                    });
                }
                processPkg(data);
            } catch (e) {
                logger.error('ws rpc server process message failed. error: %s', e.stack);
            }
        });

        socket.on('close', function (code, message) {
            logger.error('rpc server is disconnect with remote client id: %j, code: %s, message: %s', socket.id, code,
                         message);
            delete self.sockets[socket.id];
            delete self.msgQueues[socket.id];
        });
    });

    this.on('connection', ipFilter.bind(this));

    if (this.bufferMsg) {
        this._interval = setInterval(function () {
            flush(self);
        }, this.interval);
    }

    if (!!this.debugBufferMsgInterval) {
        setInterval(function () {
            var message = '';
            var total = 0;
            for (k in self.msgQueues) {
                total += self.msgQueues[k].length;
                if (!self.sockets[k]) {
                    message += util.format('[no socket]:%s ', self.msgQueues[k].length);
                }
                else {
                    message += util.format('[%s:%s]:%s ', self.sockets[k]._socket.remoteAddress,
                                           self.sockets[k]._socket.remotePort, self.msgQueues[k].length);
                }
            }
            if( total > 0 ) {
                logger.info('msgQueues size bufferMsg: %j, total: %s, %s', self.bufferMsg, total, message);
            }
        }, this.debugBufferMsgInterval);
    }
};

var ipFilter = function (obj) {
    if (typeof this.whitelist === 'function') {
        var self = this;
        self.whitelist(function (err, tmpList) {
            if (err) {
                logger.error('%j.(RPC whitelist).', err);
                return;
            }
            if (!Array.isArray(tmpList)) {
                logger.error('%j is not an array.(RPC whitelist).', tmpList);
                return;
            }
            if (!!obj && !!obj.ip && !!obj.id) {
                for (var i in tmpList) {
                    var exp = new RegExp(tmpList[i]);
                    if (exp.test(obj.ip)) {
                        return;
                    }
                }
                var sock = self.sockets[obj.id];
                if (sock) {
                    sock.close();
                    logger.warn('%s is rejected(RPC whitelist).', obj.ip);
                }
            }
        });
    }
};

pro.close = function () {
    if (!!this.closed) {
        return;
    }
    this.closed = true;
    if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
    }
    try {
        this.server.close();
    } catch (err) {
        logger.error('rpc server close error: %s', err.stack);
    }
    this.emit('closed');
};

var cloneError = function (origin) {
    // copy the stack infos for Error instance json result is empty
    var res = {
        msg: origin.msg,
        stack: origin.stack
    };
    return res;
};

var processMsg = function (socket, acceptor, pkg) {
    var tracer = new Tracer(acceptor.rpcLogger, acceptor.rpcDebugLog, pkg.remote, pkg.source, pkg.msg, pkg.traceId,
                            pkg.seqId);
    tracer.info('server', __filename, 'processMsg', 'ws-acceptor receive message and try to process message');
    acceptor.cb.call(null, tracer, pkg.msg, function () {
        var args = Array.prototype.slice.call(arguments, 0);
        for (var i = 0, l = args.length; i < l; i++) {
            if (args[i] instanceof Error) {
                args[i] = cloneError(args[i]);
            }
        }
        var resp;
        if (tracer.isEnabled) {
            resp = {
                traceId: tracer.id,
                seqId: tracer.seq,
                source: tracer.source,
                id: pkg.id,
                resp: Array.prototype.slice.call(args, 0)
            };
        }
        else {
            resp = {id: pkg.id, resp: Array.prototype.slice.call(args, 0)};
        }
        if (acceptor.bufferMsg) {
            enqueue(socket, acceptor, resp);
        } else {
            doSend(socket, acceptor, resp);
        }
    });
};

var processMsgs = function (socket, acceptor, pkgs) {
    for (var i = 0, l = pkgs.length; i < l; i++) {
        processMsg(socket, acceptor, pkgs[i]);
    }
};

var enqueue = function (socket, acceptor, msg) {
    var queue = acceptor.msgQueues[socket.id];
    if (!queue) {
        queue = acceptor.msgQueues[socket.id] = [];
    }
    queue.push(msg);
};

var flush = function (acceptor) {
    var sockets = acceptor.sockets, queues = acceptor.msgQueues, queue, socket;
    for (var socketId in queues) {
        socket = sockets[socketId];
        if (!socket) {
            // clear pending messages if the socket not exist any more
            delete queues[socketId];
            continue;
        }
        queue = queues[socketId];
        if (!queue.length) {
            continue;
        }
        doSend(socket, acceptor, queue);
        queues[socketId] = [];
    }
};

var doSend = function (socket, acceptor, dataObj) {
    var str = JSON.stringify(dataObj);
    logger.debug("ws rpc server send str len: %s", str.length);

    if (acceptor.useZipCompress && str.length > acceptor.doZipLength) {
        process.nextTick(function () {
            zlib.gzip(str, function (err, result) {
                if (!!err) {
                    logger.error('ws rpc server send message by zip compress error: %s', err.stack);
                    socket.send(str);
                    return;
                }
                logger.debug("ws rpc server send message by zip compress, buffer len: %s, rate: %s", result.length,
                             result.length / str.length);
                socket.send(result, {binary: true, mask: true});
            });
        });
    }
    else {
        logger.debug("ws rpc server send message, len: %s, message: %s", str.length, str);
        socket.send(str);
    }
};

/**
 * create acceptor
 *
 * @param opts init params
 * @param cb(tracer, msg, cb) callback function that would be invoked when new message arrives
 */
module.exports.create = function (opts, cb) {
    return new Acceptor(opts || {}, cb);
};
