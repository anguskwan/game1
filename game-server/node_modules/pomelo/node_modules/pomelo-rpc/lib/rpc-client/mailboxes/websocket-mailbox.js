var util = require('util');
var utils = require('../../util/utils');
var wsClient = require('ws');
var zlib = require('zlib');
var Tracer = require('../../util/tracer');
var constants = require('../../util/constants');
var EventEmitter = require('events').EventEmitter;
var logger = require('pomelo-logger').getLogger('pomelo-rpc', __filename);
var _ = require('underscore');

var DEFAULT_CALLBACK_TIMEOUT = 10 * 1000;
var DEFAULT_INTERVAL = 50;

var KEEP_ALIVE_TIMEOUT = 10 * 1000;
var KEEP_ALIVE_INTERVAL = 30 * 1000;

var DEFAULT_ZIP_LENGTH = 256;
var DEFAULT_USE_ZIP_COMPRESS = true;

var MailBox = function (server, opts) {
    EventEmitter.call(this);
    this.curId = 0;
    this.id = server.id;
    this.host = server.host;
    this.port = server.port;
    this.requests = {};
    this.timeout = {};
    this.queue = [];
    this.bufferMsg = opts.bufferMsg;
    this.interval = opts.interval || constants.DEFAULT_PARAM.INTERVAL;
    this.timeoutValue = opts.timeout || constants.DEFAULT_PARAM.CALLBACK_TIMEOUT;
    this.connected = false;
    this.closed = false;
    this.opts = opts;
    this._KPinterval = null;
    this._KP_last_ping_time = -1;
    this._KP_last_pong_time = -1;
    this.doZipLength = opts.doZipLength || DEFAULT_ZIP_LENGTH;
    this.useZipCompress = opts.useZipCompress || DEFAULT_USE_ZIP_COMPRESS;
};
util.inherits(MailBox, EventEmitter);

var pro = MailBox.prototype;

pro.connect = function (tracer, cb) {
    tracer.info('client', __filename, 'connect', 'ws-mailbox try to connect');
    if (this.connected) {
        tracer.error('client', __filename, 'connect', 'mailbox has already connected');
        utils.invokeCallback(cb, new Error('mailbox has already connected.'));
        return;
    }

    this.socket = wsClient.connect('ws://' + this.host + ':' + this.port);

    var self = this;

    var processPkg = function (pkg) {
        logger.debug("ws rpc client received message, len: %s, message: %s", pkg.length, pkg);
        pkg = JSON.parse(pkg);

        if (pkg instanceof Array) {
            processMsgs(self, pkg);
        } else {
            processMsg(self, pkg);
        }
    }

    this.socket.on('message', function (data, flags) {
        try {
            if (flags.binary) {
                logger.debug('ws rpc received message flags.binary, len: %s', data.length);
                return zlib.gunzip(data, function (err, result) {
                    if (!!err) {
                        logger.error('ws rpc client received binary message error: %s', err.stack);
                        return;
                    }
                    logger.debug("ws rpc client received message unzip len: %s, message: %s", result.length, result);
                    processPkg(result);
                });
            }
            processPkg(data);
        } catch (e) {
            logger.error('ws rpc client process message failed. error: %j', e.stack);
        }
    });

    this.socket.on('open', function () {
        logger.warn('rpc socket connected to remote server host: %s, port: %s', self.host, self.port);
        if (self.connected) {
            return;
        }
        self.connected = true;
        if (self.bufferMsg) {
            self._interval = setInterval(function () {
                flush(self);
            }, self.interval);
        }
        self._KPinterval = setInterval(function () {
            checkKeepAlive(self);
        }, KEEP_ALIVE_INTERVAL);
        utils.invokeCallback(cb);
    });

    this.socket.on('error', function (err) {
        logger.error('rpc socket is error, remote server host: %s, port: %s, err: %j', self.host, self.port, err);
        self.emit('close', self.id);
        utils.invokeCallback(cb, err);
    });

    this.socket.on('close', function (code, message) {
        logger.error('rpc socket is disconnect code: %s, message: %s', code, message);
        var reqs = self.requests, cb;
        for (var id in reqs) {
            cb = reqs[id];
            utils.invokeCallback(cb, tracer, new Error('disconnect with remote server.'));
        }
        self.emit('close', self.id);
    });

//  this.socket.on('ping', function (data, flags) {
//  });
    this.socket.on('pong', function (data, flags) {
        logger.debug('ws received pong: %s', data);
        self._KP_last_pong_time = Date.now();
    });
};

var checkKeepAlive = function (mailbox) {
    if (!!mailbox.closed) {
        return;
    }
    if (mailbox._KP_last_ping_time > 0) {
        if (mailbox._KP_last_pong_time < mailbox._KP_last_ping_time ||
            mailbox._KP_last_pong_time - mailbox._KP_last_ping_time > KEEP_ALIVE_TIMEOUT) {
            logger.error('ws rpc client checkKeepAlive error');
            mailbox.socket.emit('close', 1, 'checkKeepAlive');
            return;
        }
    }
    mailbox.socket.ping();
    mailbox._KP_last_ping_time = Date.now();
};

/**
 * close mailbox
 */
pro.close = function () {
    if (this.closed) {
        return;
    }
    this.closed = true;
    if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
    }
    if (this._KPinterval) {
        clearInterval(this._KPinterval);
        this._KPinterval = null;
    }
    this.socket.close();
    this._KP_last_ping_time = -1;
    this._KP_last_pong_time = -1;
};

/**
 * send message to remote server
 *
 * @param msg {service:"", method:"", args:[]}
 * @param opts {} attach info to send method
 * @param cb declaration decided by remote interface
 */
pro.send = function (tracer, msg, opts, cb) {
    tracer.info('client', __filename, 'send', 'ws-mailbox try to send');
    if (!this.connected) {
        tracer.error('client', __filename, 'send', 'ws-mailbox not init');
        utils.invokeCallback(cb, tracer, new Error('ws-mailbox is not init'));
        return;
    }

    if (this.closed) {
        tracer.error('client', __filename, 'send', 'mailbox has already closed');
        utils.invokeCallback(cb, tracer, new Error('ws-mailbox has already closed'));
        return;
    }

    var id = this.curId++;
    this.requests[id] = cb;
    setCbTimeout(this, id, tracer, cb);

    var pkg;
    if (tracer.isEnabled) {
        pkg = {traceId: tracer.id, seqId: tracer.seq, source: tracer.source, remote: tracer.remote, id: id, msg: msg};
    }
    else {
        pkg = {id: id, msg: msg};
    }
    if (this.bufferMsg) {
        enqueue(this, pkg);
    } else {
        doSend(this.socket, this, pkg);
        //this.socket.send(JSON.stringify({body: pkg}));
    }
};

var enqueue = function (mailbox, msg) {
    mailbox.queue.push(msg);
};

var flush = function (mailbox) {
    if (mailbox.closed || !mailbox.queue.length) {
        return;
    }
    doSend(mailbox.socket, mailbox, mailbox.queue);
    //mailbox.socket.send(JSON.stringify({body: mailbox.queue}));
    mailbox.queue = [];
};

var doSend = function (socket, mailbox, dataObj) {
    var str = JSON.stringify(dataObj);
    logger.debug("ws rpc client send str len: %s", str.length);

    if (mailbox.useZipCompress && str.length > mailbox.doZipLength) {
        process.nextTick(function () {
            zlib.gzip(str, function (err, result) {
                if (!!err) {
                    logger.error('ws rpc client send message by zip compress error: %s', err.stack);
                    socket.send(str);
                    return;
                }
                logger.debug("ws rpc client send message by zip compress, buffer len: %s, rate: %s", result.length,
                             result.length / str.length);
                socket.send(result, {binary: true, mask: true});
            });
        });
    }
    else {
        logger.debug("ws rpc client send message, len: %s, message: %s", str.length, str);
        socket.send(str);
    }
};

var processMsgs = function (mailbox, pkgs) {
    for (var i = 0, l = pkgs.length; i < l; i++) {
        processMsg(mailbox, pkgs[i]);
    }
};

var processMsg = function (mailbox, pkg) {
    clearCbTimeout(mailbox, pkg.id);
    var cb = mailbox.requests[pkg.id];
    if (!cb) {
        return;
    }
    delete mailbox.requests[pkg.id];

    var tracer = new Tracer(mailbox.opts.rpcLogger, mailbox.opts.rpcDebugLog, mailbox.opts.clientId, pkg.source,
                            pkg.resp, pkg.traceId, pkg.seqId);
    var args = [tracer, null];

    pkg.resp.forEach(function (arg) {
        args.push(arg);
    });

    cb.apply(null, args);
};

var setCbTimeout = function (mailbox, id, tracer, cb) {
    var timer = setTimeout(function () {
        clearCbTimeout(mailbox, id);
        if (!!mailbox.requests[id]) {
            delete mailbox.requests[id];
        }
        logger.error('rpc callback timeout, id: %s, remote server host: %s, port: %s, msg: %j, mailbox.requests: %s',
                     id, mailbox.host, mailbox.port, tracer.msg, _.size(mailbox.requests));
        utils.invokeCallback(cb, tracer, new Error('rpc callback timeout'));
    }, mailbox.timeoutValue);
    mailbox.timeout[id] = timer;
};

var clearCbTimeout = function (mailbox, id) {
    if (!mailbox.timeout[id]) {
        logger.warn('timer is not exsits, id: %s, host: %s, port: %s', id, mailbox.host, mailbox.port);
        return;
    }
    clearTimeout(mailbox.timeout[id]);
    delete mailbox.timeout[id];
};

/**
 * Factory method to create mailbox
 *
 * @param {Object} server remote server info {id:"", host:"", port:""}
 * @param {Object} opts construct parameters
 *                      opts.bufferMsg {Boolean} msg should be buffered or send immediately.
 *                      opts.interval {Boolean} msg queue flush interval if bufferMsg is true. default is 50 ms
 */
module.exports.create = function (server, opts) {
    return new MailBox(server, opts || {});
};